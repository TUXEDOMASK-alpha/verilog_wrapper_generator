#!/usr/bin/env python3
"""
Verilog Wrapper Generator Tool

This tool creates Verilog wrapper files by instantiating modules and connecting their ports.
It takes a configuration that specifies module files, instance names, and port mappings.
"""

import re
import json
import argparse
import os
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
from pathlib import Path


@dataclass
class ValidationError:
    """Represents a validation error with details"""
    error_type: str
    message: str
    config_line: str
    severity: str = "ERROR"  # ERROR, WARNING


class ErrorReporter:
    """Handles error reporting and logging"""
    
    def __init__(self):
        self.errors = []
        self.warnings = []
    
    def add_error(self, error_type: str, message: str, config_line: str = ""):
        """Add an error to the report"""
        error = ValidationError(error_type, message, config_line, "ERROR")
        self.errors.append(error)
        print(f"ERROR [{error_type}]: {message}")
        if config_line:
            print(f"  Config line: {config_line}")
    
    def add_warning(self, error_type: str, message: str, config_line: str = ""):
        """Add a warning to the report"""
        warning = ValidationError(error_type, message, config_line, "WARNING")
        self.warnings.append(warning)
        print(f"WARNING [{error_type}]: {message}")
        if config_line:
            print(f"  Config line: {config_line}")
    
    def has_errors(self) -> bool:
        """Check if there are any errors"""
        return len(self.errors) > 0
    
    def generate_error_report(self):
        """Generate error report files in rpt directory"""
        import os
        
        # Create rpt directory if it doesn't exist
        rpt_dir = "./rpt"
        if not os.path.exists(rpt_dir):
            os.makedirs(rpt_dir)
        
        # Write error report
        with open(os.path.join(rpt_dir, "Error_report.list"), 'w') as f:
            f.write("# Configuration Errors Report\n")
            f.write("# Generated by Verilog Wrapper Generator\n\n")
            
            if self.errors:
                f.write("=== ERRORS ===\n")
                for error in self.errors:
                    f.write(f"[{error.error_type}] {error.message}\n")
                    if error.config_line:
                        f.write(f"  Config: {error.config_line}\n")
                    f.write("\n")
            
            if self.warnings:
                f.write("=== WARNINGS ===\n")
                for warning in self.warnings:
                    f.write(f"[{warning.error_type}] {warning.message}\n")
                    if warning.config_line:
                        f.write(f"  Config: {warning.config_line}\n")
                    f.write("\n")
            
            if not self.errors and not self.warnings:
                f.write("No errors or warnings found.\n")
        
        print(f"\nError report saved to: {os.path.join(rpt_dir, 'Error_report.list')}")


@dataclass
class Port:
    """Represents a Verilog port with its direction and width"""
    name: str
    direction: str  # 'input', 'output', 'inout'
    width: Optional[str] = None  # e.g., '[7:0]' or None for single bit


@dataclass
class Module:
    """Represents a Verilog module with its ports"""
    name: str
    ports: List[Port]
    file_path: str


@dataclass
class Instance:
    """Represents a module instance with port mappings"""
    module: Module
    instance_name: str
    parameters: Dict[str, str]  # parameter_name -> value
    port_mapping: Dict[str, str]  # module_port -> top_port


class VerilogParser:
    """Parser for extracting module information from Verilog files"""
    
    def __init__(self):
        # Regex patterns for parsing Verilog
        # Updated to handle modules with parameters: module name #(parameters) (ports);
        self.module_pattern = re.compile(r'module\s+(\w+)\s*(?:#\s*\([^)]*\))?\s*\((.*?)\);', re.DOTALL)
        
        # Enhanced patterns for different port declaration styles
        # ANSI style: input [7:0] data, output reg [15:0] result
        self.ansi_port_pattern = re.compile(r'(input|output|inout)\s*(wire|reg)?\s*(\[.*?\])?\s*(\w+(?:\s*,\s*\w+)*)', re.MULTILINE)
        
        # Traditional style: input data; output [15:0] result; input wire data; output reg [15:0] result;
        # Use non-capturing group for wire/reg and make sure it's followed by whitespace
        self.traditional_port_pattern = re.compile(r'(input|output|inout)\s+(?:wire\s+|reg\s+)?(\[.*?\])?\s*(\w+(?:\s*,\s*\w+)*)\s*;', re.MULTILINE)
        
        # Port list in module declaration
        self.port_list_pattern = re.compile(r'(\w+)(?:\s*,\s*(\w+))*')
    
    def _find_module_declaration(self, content: str) -> Optional[tuple]:
        """Find module declaration handling complex parameter declarations"""
        # Remove all whitespace and newlines for easier parsing
        clean_content = re.sub(r'\s+', ' ', content)
        
        # Look for module keyword
        module_match = re.search(r'module\s+(\w+)', clean_content)
        if not module_match:
            return None
        
        module_name = module_match.group(1)
        
        # Find the start of module declaration
        module_start = module_match.start()
        
        # Look for parameter section (optional)
        param_start = clean_content.find('#', module_start)
        if param_start != -1:
            # Module has parameters, find the end of parameter section
            paren_start = clean_content.find('(', param_start)
            if paren_start == -1:
                return None
            
            # Find matching closing parenthesis for parameters
            paren_count = 1
            i = paren_start + 1
            while i < len(clean_content) and paren_count > 0:
                if clean_content[i] == '(':
                    paren_count += 1
                elif clean_content[i] == ')':
                    paren_count -= 1
                i += 1
            
            if paren_count > 0:
                return None  # Unmatched parentheses
            
            # Find port section start
            port_start = clean_content.find('(', i)
        else:
            # No parameters, find port section directly
            port_start = clean_content.find('(', module_start)
        
        if port_start == -1:
            return None
        
        # Find the end of port section
        paren_count = 1
        i = port_start + 1
        while i < len(clean_content) and paren_count > 0:
            if clean_content[i] == '(':
                paren_count += 1
            elif clean_content[i] == ')':
                paren_count -= 1
            i += 1
        
        if paren_count > 0:
            return None  # Unmatched parentheses
        
        # Check if followed by semicolon
        j = i
        while j < len(clean_content) and clean_content[j].isspace():
            j += 1
        
        if j >= len(clean_content) or clean_content[j] != ';':
            return None
        
        # Extract port section
        port_section = clean_content[port_start + 1:i - 1]
        
        return (module_name, port_section)
    
    def _find_specific_module(self, content: str, target_module_name: str) -> Optional[tuple]:
        """Find a specific module declaration by name"""
        # Use the same robust parsing logic as _find_module_declaration
        clean_content = re.sub(r'\s+', ' ', content)
        
        # Look for the specific module
        module_pattern = rf'module\s+{re.escape(target_module_name)}\b'
        module_match = re.search(module_pattern, clean_content)
        if not module_match:
            return None
        
        module_start = module_match.start()
        
        # Look for parameter section (optional)
        param_start = clean_content.find('#', module_start)
        if param_start != -1:
            # Module has parameters, find the end of parameter section
            paren_start = clean_content.find('(', param_start)
            if paren_start == -1:
                return None
            
            # Find matching closing parenthesis for parameters
            paren_count = 1
            i = paren_start + 1
            while i < len(clean_content) and paren_count > 0:
                if clean_content[i] == '(':
                    paren_count += 1
                elif clean_content[i] == ')':
                    paren_count -= 1
                i += 1
            
            if paren_count > 0:
                return None  # Unmatched parentheses
            
            # Find port section start
            port_start = clean_content.find('(', i)
        else:
            # No parameters, find port section directly
            port_start = clean_content.find('(', module_start)
        
        if port_start == -1:
            return None
        
        # Find the end of port section
        paren_count = 1
        i = port_start + 1
        while i < len(clean_content) and paren_count > 0:
            if clean_content[i] == '(':
                paren_count += 1
            elif clean_content[i] == ')':
                paren_count -= 1
            i += 1
        
        if paren_count > 0:
            return None  # Unmatched parentheses
        
        # Check if followed by semicolon
        j = i
        while j < len(clean_content) and clean_content[j].isspace():
            j += 1
        
        if j >= len(clean_content) or clean_content[j] != ';':
            return None
        
        # Extract port section
        port_section = clean_content[port_start + 1:i - 1]
        
        return (target_module_name, port_section)
    
    def parse_module(self, file_path: str, target_module_name: str = None) -> Module:
        """Parse a Verilog file and extract module information
        
        Args:
            file_path: Path to the Verilog file
            target_module_name: Specific module name to parse (optional)
        """
        try:
            with open(file_path, 'r') as f:
                content = f.read()
        except FileNotFoundError:
            raise FileNotFoundError(f"Verilog file not found: {file_path}")
        
        # Remove comments
        content = re.sub(r'//.*', '', content)
        content = re.sub(r'/\*.*?\*/', '', content, flags=re.DOTALL)
        
        # If target module name is specified, find that specific module
        if target_module_name:
            module_match = self._find_specific_module(content, target_module_name)
            if not module_match:
                raise ValueError(f"Module '{target_module_name}' not found in {file_path}")
        else:
            # Find first module declaration with improved parsing
            module_match = self._find_module_declaration(content)
            if not module_match:
                raise ValueError(f"No module declaration found in {file_path}")
        
        module_name = module_match[0]
        port_list = module_match[1]
        
        # Get module content
        module_end = content.find('endmodule')
        if module_end == -1:
            raise ValueError(f"No endmodule found in {file_path}")
        
        # Find the end of module declaration to extract module body
        module_decl_end = content.find(';', content.find('module'))
        if module_decl_end == -1:
            raise ValueError(f"Invalid module declaration in {file_path}")
        
        module_content = content[module_decl_end + 1:module_end]
        
        # Remove parameter and localparam declarations from module body only
        module_content = re.sub(r'parameter\s+[^;]+;', '', module_content, flags=re.MULTILINE)
        module_content = re.sub(r'localparam\s+[^;]+;', '', module_content, flags=re.MULTILINE)
        
        # Parse ports using enhanced parser
        ports = self._parse_ports(port_list, module_content)
        
        return Module(name=module_name, ports=ports, file_path=file_path)
    
    def _parse_ports(self, port_list: str, module_content: str) -> List[Port]:
        """Enhanced port parsing that handles both ANSI and traditional styles"""
        ports = []
        port_info = {}  # port_name -> Port
        
        # First, try to parse ANSI-style ports (ports with directions in module header)
        ansi_ports = self._parse_ansi_ports(port_list)
        if ansi_ports:
            return ansi_ports
        
        # If not ANSI style, parse traditional style
        # Step 1: Get port names from module declaration
        port_names = []
        if port_list.strip():
            # Remove any existing direction/width info and extract just names
            clean_port_list = re.sub(r'(input|output|inout)\s*(\[.*?\])?\s*', '', port_list)
            port_names = [p.strip() for p in clean_port_list.split(',') if p.strip()]
        
        # Step 2: Find port declarations in module body
        # Traditional style declarations
        traditional_matches = self.traditional_port_pattern.findall(module_content)
        for direction, width, port_names_str in traditional_matches:
            port_names_list = [p.strip() for p in port_names_str.split(',')]
            for port_name in port_names_list:
                if port_name:
                    port_info[port_name] = Port(
                        name=port_name, 
                        direction=direction, 
                        width=width if width else None
                    )
        
        # Step 3: Create ports list maintaining order from module declaration
        if port_names:
            for port_name in port_names:
                if port_name in port_info:
                    ports.append(port_info[port_name])
                else:
                    # Default to input if not found in declarations
                    ports.append(Port(name=port_name, direction='input', width=None))
        else:
            # If no port list, just use what we found in declarations
            ports = list(port_info.values())
        
        return ports
    
    def _parse_ansi_ports(self, port_list: str) -> List[Port]:
        """Parse ANSI-style port declarations"""
        if not port_list.strip():
            return []
        
        ports = []
        
        # Check if this looks like ANSI style (contains direction keywords)
        if not re.search(r'(input|output|inout)', port_list):
            return []
        
        # Split by commas, but be careful with brackets
        port_parts = self._split_port_list(port_list)
        
        current_direction = None
        current_width = None
        
        for part in port_parts:
            part = part.strip()
            if not part:
                continue
            
            # Check for direction change
            # First try to match with wire/reg keyword as separate word
            direction_match = re.match(r'(input|output|inout)\s+(wire|reg)\s+(\[.*?\])?\s*(.+)', part)
            if direction_match:
                current_direction = direction_match.group(1)
                wire_reg_type = direction_match.group(2)  # This is the wire/reg keyword, not part of port name
                current_width = direction_match.group(3)
                remaining = direction_match.group(4)
                
                # Extract port names from remaining part
                port_names = [p.strip() for p in remaining.split(',') if p.strip()]
                for port_name in port_names:
                    ports.append(Port(name=port_name, direction=current_direction, width=current_width))
            else:
                # Try to match without wire/reg keyword
                direction_match = re.match(r'(input|output|inout)\s+(\[.*?\])?\s*(.+)', part)
                if direction_match:
                    current_direction = direction_match.group(1)
                    current_width = direction_match.group(2)
                    remaining = direction_match.group(3)
                    
                    # Extract port names from remaining part
                    port_names = [p.strip() for p in remaining.split(',') if p.strip()]
                    for port_name in port_names:
                        ports.append(Port(name=port_name, direction=current_direction, width=current_width))
                else:
                    # No direction keyword, use current direction
                    if current_direction:
                        port_names = [p.strip() for p in part.split(',') if p.strip()]
                        for port_name in port_names:
                            ports.append(Port(name=port_name, direction=current_direction, width=current_width))
        
        return ports
    
    def _split_port_list(self, port_list: str) -> List[str]:
        """Split port list by commas, respecting brackets"""
        parts = []
        current = ""
        bracket_depth = 0
        
        for char in port_list:
            if char == '[':
                bracket_depth += 1
            elif char == ']':
                bracket_depth -= 1
            elif char == ',' and bracket_depth == 0:
                parts.append(current.strip())
                current = ""
                continue
            
            current += char
        
        if current.strip():
            parts.append(current.strip())
        
        return parts


class ConfigParser:
    """Parser for reading configuration files"""
    
    def parse_config_directory(self, config_dir: str) -> Dict:
        """Parse all configuration files from a directory"""
        config = {
            'top_module': 'top_wrapper',
            'instances': [],
            'top_ports': [],
            'instance_connections': [],
            'instance_to_top': {}
        }
        
        import os
        
        # Parse top module configuration - try both .cmd and .txt extensions
        top_module_file = os.path.join(config_dir, '01_top_module.cmd')
        if not os.path.exists(top_module_file):
            top_module_file = os.path.join(config_dir, 'top_module.txt')
        if os.path.exists(top_module_file):
            top_module_config = self._parse_top_module(top_module_file)
            config['top_module'] = top_module_config['name']
            config['top_module_parameters'] = top_module_config['parameters']
        else:
            config['top_module_parameters'] = {}
        
        # Parse instances
        instances_file = os.path.join(config_dir, '02_instances.cmd')
        if not os.path.exists(instances_file):
            instances_file = os.path.join(config_dir, 'instances.txt')
        if os.path.exists(instances_file):
            config['instances'] = self._parse_instances(instances_file)
        
        # Parse top ports
        top_ports_file = os.path.join(config_dir, '03_top_ports.cmd')
        if not os.path.exists(top_ports_file):
            top_ports_file = os.path.join(config_dir, 'top_ports.txt')
        if os.path.exists(top_ports_file):
            config['top_ports'] = self._parse_top_ports(top_ports_file)
        
        # Parse instance to top mappings
        instance_to_top_file = os.path.join(config_dir, '04_instance_to_top.cmd')
        if not os.path.exists(instance_to_top_file):
            instance_to_top_file = os.path.join(config_dir, 'instance_to_top.txt')
        if os.path.exists(instance_to_top_file):
            config['instance_to_top'] = self._parse_instance_to_top(instance_to_top_file)
        
        # Parse instance connections
        instance_connections_file = os.path.join(config_dir, '05_instance_connections.cmd')
        if not os.path.exists(instance_connections_file):
            instance_connections_file = os.path.join(config_dir, 'instance_connections.txt')
        if os.path.exists(instance_connections_file):
            config['instance_connections'] = self._parse_instance_connections(instance_connections_file)
        
        # Parse instance port exports
        instance_export_port_file = os.path.join(config_dir, '06_instance_export_port.cmd')
        if not os.path.exists(instance_export_port_file):
            instance_export_port_file = os.path.join(config_dir, 'instance_export_port.txt')
        if os.path.exists(instance_export_port_file):
            config['instance_export_ports'] = self._parse_instance_export_ports(instance_export_port_file)
        else:
            config['instance_export_ports'] = []
        
        return config
    
    def _parse_top_module(self, file_path: str) -> Dict:
        """Parse top module configuration from file
        
        Returns dict with 'name' and 'parameters' keys
        """
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        config = {
            'name': 'top_wrapper',
            'parameters': {}
        }
        
        current_section = None
        
        for line in lines:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            # Check for section headers
            if line.startswith('[') and line.endswith(']'):
                current_section = line[1:-1]
                continue
            
            if current_section == 'TOP_MODULE_NAME':
                config['name'] = line
            elif current_section == 'TOP_MODULE_PARAMETERS':
                # Parse parameter line: PARAM_NAME = PARAM_VALUE
                if '=' in line:
                    param_name, param_value = line.split('=', 1)
                    config['parameters'][param_name.strip()] = param_value.strip()
        
        return config
    
    def _parse_instances(self, file_path: str) -> List[Dict]:
        """Parse instances from file"""
        instances = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        in_instances_section = False
        
        for line in lines:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            if line.startswith('[INSTANCES]'):
                in_instances_section = True
                continue
            
            if in_instances_section and '|' in line:
                parts = [p.strip() for p in line.split('|')]
                if len(parts) >= 2:
                    instance_name = parts[0]
                    module_file = parts[1]
                    module_name = None
                    parameters = {}
                    
                    # Check if module name is specified separately (3+ parts)
                    if len(parts) >= 3 and parts[2] and not '=' in parts[2]:
                        # parts[2] is module name, parameters start from parts[3]
                        module_name = parts[2]
                        if len(parts) > 3 and parts[3]:
                            param_str = parts[3]
                            for param in param_str.split(','):
                                if '=' in param:
                                    key, value = param.split('=', 1)
                                    parameters[key.strip()] = value.strip()
                    elif len(parts) > 2 and parts[2]:
                        # parts[2] contains parameters (backward compatibility)
                        param_str = parts[2]
                        for param in param_str.split(','):
                            if '=' in param:
                                key, value = param.split('=', 1)
                                parameters[key.strip()] = value.strip()
                    
                    instances.append({
                        'instance_name': instance_name,
                        'file': module_file,
                        'module_name': module_name,  # New field for explicit module name
                        'parameters': parameters,
                        'port_mapping': {}
                    })
        
        return instances
    
    def _parse_top_ports(self, file_path: str) -> List[Port]:
        """Parse top ports from file"""
        ports = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        in_ports_section = False
        
        for line in lines:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            if line.startswith('[TOP_PORTS]'):
                in_ports_section = True
                continue
            
            if in_ports_section and '|' in line:
                parts = [p.strip() for p in line.split('|')]
                if len(parts) >= 3:
                    direction = parts[0]
                    width = parts[1] if parts[1] else None
                    name = parts[2]
                    
                    ports.append(Port(name=name, direction=direction, width=width))
        
        return ports
    
    def _parse_instance_to_top(self, file_path: str) -> Dict[str, str]:
        """Parse instance to top mappings from file"""
        mappings = {}
        
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        in_mapping_section = False
        
        for line in lines:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            if line.startswith('[INSTANCE_TO_TOP]'):
                in_mapping_section = True
                continue
            
            if in_mapping_section and '->' in line:
                parts = [p.strip() for p in line.split('->')]
                if len(parts) == 2:
                    instance_port = parts[0]
                    top_port = parts[1]
                    mappings[instance_port] = top_port
        
        return mappings
    
    def _parse_instance_connections(self, file_path: str) -> List[Dict]:
        """Parse instance connections from file"""
        connections = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        in_connections_section = False
        
        for line in lines:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            if line.startswith('[INSTANCE_CONNECTIONS]'):
                in_connections_section = True
                continue
            
            if in_connections_section and '->' in line:
                parts = [p.strip() for p in line.split('->')]
                if len(parts) == 2:
                    source = parts[0]
                    target = parts[1]
                    connections.append({
                        'source': source,
                        'target': target
                    })
        
        return connections
    
    def _parse_instance_export_ports(self, file_path: str) -> List[Dict]:
        """Parse instance export ports from file
        
        Format: instance_name.port_name [-> new_port_name]
        If new_port_name is not specified, use original port_name
        """
        export_ports = []
        
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        in_export_section = False
        
        for line in lines:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            if line.startswith('[INSTANCE_EXPORT_PORTS]'):
                in_export_section = True
                continue
            
            if in_export_section:
                if '->' in line:
                    # Format: instance.port -> new_port_name
                    parts = [p.strip() for p in line.split('->')]
                    if len(parts) == 2:
                        instance_port = parts[0]
                        new_port_name = parts[1]
                        
                        if '.' in instance_port:
                            instance_name, port_name = instance_port.split('.', 1)
                            export_ports.append({
                                'instance_name': instance_name.strip(),
                                'port_name': port_name.strip(),
                                'export_name': new_port_name.strip()
                            })
                else:
                    # Format: instance.port (use original port name)
                    if '.' in line:
                        instance_name, port_name = line.split('.', 1)
                        export_ports.append({
                            'instance_name': instance_name.strip(),
                            'port_name': port_name.strip(),
                            'export_name': port_name.strip()  # Use original port name
                        })
        
        return export_ports
    
    def parse_input_spec(self, file_path: str) -> Dict:
        """Parse input specification file and return configuration"""
        config = {
            'top_module': 'top_wrapper',
            'instances': []
        }
        
        instances = {}
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
        except FileNotFoundError:
            raise FileNotFoundError(f"Input specification file not found: {file_path}")
        
        current_section = None
        
        for line in lines:
            line = line.strip()
            
            # Skip empty lines and comments
            if not line or line.startswith('#'):
                continue
            
            # Check for section headers
            if line.startswith('[') and line.endswith(']'):
                current_section = line[1:-1]
                continue
            
            # Process sections
            if current_section == 'TOP_MODULE':
                config['top_module'] = line
            
            elif current_section == 'INSTANCES':
                if '|' in line:
                    parts = [p.strip() for p in line.split('|')]
                    if len(parts) == 2:
                        instance_name, file_path = parts
                        instances[instance_name] = {
                            'instance_name': instance_name,
                            'file': file_path,
                            'port_mapping': {}
                        }
            
            elif current_section == 'PORT_MAPPING':
                if '->' in line:
                    parts = [p.strip() for p in line.split('->')]
                    if len(parts) == 2:
                        left, right = parts
                        if '.' in left:
                            inst_name, port_name = left.split('.', 1)
                            inst_name = inst_name.strip()
                            port_name = port_name.strip()
                            top_port = right.strip()
                            
                            if inst_name in instances:
                                instances[inst_name]['port_mapping'][port_name] = top_port
        
        config['instances'] = list(instances.values())
        return config


class WrapperGenerator:
    """Generates Verilog wrapper files"""
    
    def __init__(self):
        self.parser = VerilogParser()
        self.config_parser = ConfigParser()
        self.error_reporter = ErrorReporter()
    
    def generate_wrapper_from_spec(self, spec_file: str) -> str:
        """Generate wrapper Verilog code from input specification file"""
        config = self.config_parser.parse_input_spec(spec_file)
        return self.generate_wrapper(config)
    
    def generate_wrapper_from_config(self, config_dir: str) -> str:
        """Generate wrapper Verilog code from configuration directory"""
        config = self.config_parser.parse_config_directory(config_dir)
        
        # Validate configuration before generating wrapper
        if not self._validate_configuration(config):
            print(f"\nValidation failed. Found {len(self.error_reporter.errors)} error(s) and {len(self.error_reporter.warnings)} warning(s).")
            return ""
        
        return self.generate_wrapper_advanced(config)
    
    def generate_wrapper_advanced(self, config: Dict) -> str:
        """Generate wrapper Verilog code from advanced configuration"""
        top_module_name = config.get('top_module', 'top_wrapper')
        top_module_parameters = config.get('top_module_parameters', {})
        instances_config = config.get('instances', [])
        top_ports = config.get('top_ports', [])
        instance_to_top_config = config.get('instance_to_top', {})
        instance_connections = config.get('instance_connections', [])
        instance_export_ports = config.get('instance_export_ports', [])
        
        # Parse all modules and create instances
        instances = []
        
        for inst_config in instances_config:
            # Parse module with specific module name if provided
            target_module_name = inst_config.get('module_name')
            module = self.parser.parse_module(inst_config['file'], target_module_name)
            instance_name = inst_config['instance_name']
            parameters = inst_config.get('parameters', {})
            
            # Build port mapping from instance_to_top
            port_mapping = {}
            for inst_port, top_port in instance_to_top_config.items():
                if inst_port.startswith(f"{instance_name}."):
                    port_name = inst_port.split('.', 1)[1]
                    port_mapping[port_name] = top_port
            
            instance = Instance(module=module, instance_name=instance_name, parameters=parameters, port_mapping=port_mapping)
            instances.append(instance)
        
        # Add exported ports to top_ports, avoiding duplicates
        exported_top_ports = self._generate_exported_ports(instances, instance_export_ports)
        
        # Create a set of existing port names to avoid duplicates
        existing_port_names = {port.name for port in top_ports}
        
        # Only add exported ports that don't already exist in manually defined ports
        filtered_exported_ports = [port for port in exported_top_ports if port.name not in existing_port_names]
        
        all_top_ports = top_ports + filtered_exported_ports
        
        # Report any skipped duplicate ports
        skipped_ports = [port.name for port in exported_top_ports if port.name in existing_port_names]
        if skipped_ports:
            for port_name in skipped_ports:
                self.error_reporter.add_warning(
                    "DUPLICATE_PORT_IGNORED", 
                    f"Exported port '{port_name}' ignored because it already exists in manual port definitions",
                    ""
                )
        
        # Generate wrapper code
        wrapper_code = self._generate_wrapper_code_advanced(top_module_name, top_module_parameters, instances, all_top_ports, instance_connections, instance_to_top_config, instance_export_ports)
        return wrapper_code
    
    def generate_wrapper(self, config: Dict) -> str:
        """Generate wrapper Verilog code from configuration"""
        top_module_name = config.get('top_module', 'top_wrapper')
        instances_config = config.get('instances', [])
        
        # Parse all modules and create instances
        instances = []
        all_top_ports = {}  # port_name -> Port
        
        for inst_config in instances_config:
            # Parse module with specific module name if provided
            target_module_name = inst_config.get('module_name')
            module = self.parser.parse_module(inst_config['file'], target_module_name)
            instance_name = inst_config['instance_name']
            port_mapping = inst_config.get('port_mapping', {})
            
            parameters = inst_config.get('parameters', {})
            instance = Instance(module=module, instance_name=instance_name, parameters=parameters, port_mapping=port_mapping)
            instances.append(instance)
            
            # Collect top-level ports
            for port in module.ports:
                if port.name in port_mapping:
                    top_port_name = port_mapping[port.name]
                    if top_port_name not in all_top_ports:
                        all_top_ports[top_port_name] = Port(
                            name=top_port_name,
                            direction=port.direction,
                            width=port.width
                        )
        
        # Generate wrapper code
        wrapper_code = self._generate_wrapper_code(top_module_name, instances, all_top_ports)
        return wrapper_code
    
    def _generate_exported_ports(self, instances: List[Instance], instance_export_ports: List[Dict]) -> List[Port]:
        """Generate Port objects for exported instance ports"""
        exported_ports = []
        
        for export_config in instance_export_ports:
            instance_name = export_config['instance_name']
            port_name = export_config['port_name']
            export_name = export_config['export_name']
            
            # Find the corresponding instance and port
            for instance in instances:
                if instance.instance_name == instance_name:
                    for port in instance.module.ports:
                        if port.name == port_name:
                            # Get instance-specific parameter values for width substitution
                            module_params = self._extract_parameters_from_module(instance.module.file_path)
                            instance_params = module_params.copy()
                            if instance.parameters:
                                for param_name, param_value in instance.parameters.items():
                                    instance_params[param_name] = param_value
                            instance_params = self._resolve_parameter_dependencies(instance_params)
                            
                            # Substitute parameter values in width
                            substituted_width = self._substitute_parameters(port.width, instance_params) if port.width else None
                            
                            # Create new port with export name and substituted width
                            exported_port = Port(
                                name=export_name,
                                direction=port.direction,
                                width=substituted_width
                            )
                            exported_ports.append(exported_port)
                            break
                    break
        
        return exported_ports
    
    def _validate_configuration(self, config: Dict) -> bool:
        """Validate the entire configuration and report errors"""
        self.error_reporter = ErrorReporter()  # Reset error reporter
        
        # Validate instances
        instances_config = config.get('instances', [])
        valid_instances = []
        
        for inst_config in instances_config:
            if self._validate_instance(inst_config):
                valid_instances.append(inst_config)
        
        # Validate connections if no critical errors in instances
        if not self.error_reporter.has_errors():
            instance_to_top_config = config.get('instance_to_top', {})
            instance_connections = config.get('instance_connections', [])
            self._validate_connections(valid_instances, instance_to_top_config, instance_connections)
        
        # Generate error report
        self.error_reporter.generate_error_report()
        
        return not self.error_reporter.has_errors()
    
    def _validate_instance(self, inst_config: Dict) -> bool:
        """Validate a single instance configuration"""
        instance_name = inst_config.get('instance_name', '')
        file_path = inst_config.get('file', '')
        module_name = inst_config.get('module_name')
        parameters = inst_config.get('parameters', {})
        
        config_line = f"{instance_name} | {file_path}"
        if module_name:
            config_line += f" | {module_name}"
        if parameters:
            param_str = ", ".join([f"{k}={v}" for k, v in parameters.items()])
            config_line += f" | {param_str}"
        
        # Check if file exists - try multiple locations
        resolved_file_path = self._resolve_file_path(file_path)
        if not resolved_file_path:
            self.error_reporter.add_error("FILE_NOT_FOUND", 
                                        f"Verilog file '{file_path}' does not exist", 
                                        config_line)
            return False
        
        # Update the file path to the resolved path
        inst_config['file'] = resolved_file_path
        
        # Try to parse the module
        try:
            module = self.parser.parse_module(resolved_file_path, module_name)
            inst_config['_parsed_module'] = module  # Cache parsed module
            
            # Validate parameters
            if parameters:
                self._validate_parameters(module, parameters, config_line)
            
            return True
            
        except ValueError as e:
            if module_name:
                self.error_reporter.add_error("MODULE_NOT_FOUND", 
                                            f"Module '{module_name}' not found in file '{file_path}'", 
                                            config_line)
            else:
                self.error_reporter.add_error("MODULE_PARSE_ERROR", 
                                            f"Failed to parse module from '{file_path}': {str(e)}", 
                                            config_line)
            return False
        except Exception as e:
            self.error_reporter.add_error("PARSE_ERROR", 
                                        f"Error parsing '{file_path}': {str(e)}", 
                                        config_line)
            return False
    
    def _validate_parameters(self, module: Module, parameters: Dict[str, str], config_line: str):
        """Validate instance parameters against module"""
        # Extract module parameters from file
        try:
            module_params = self._extract_parameters_from_module(module.file_path)
            
            for param_name, param_value in parameters.items():
                if param_name not in module_params:
                    self.error_reporter.add_warning("PARAMETER_NOT_FOUND", 
                                                   f"Parameter '{param_name}' not found in module '{module.name}'", 
                                                   config_line)
                
                # Validate parameter value format
                try:
                    # Try to evaluate if it's a numeric expression
                    if re.match(r'^[\d\+\-\*\/\(\)\s]+$', param_value):
                        eval(param_value)
                except:
                    self.error_reporter.add_warning("INVALID_PARAMETER_VALUE", 
                                                   f"Parameter '{param_name}' has invalid value '{param_value}'", 
                                                   config_line)
        except:
            pass  # If we can't extract parameters, skip validation
    
    def _validate_connections(self, instances: List[Dict], instance_to_top: Dict[str, str], instance_connections: List[Dict]):
        """Validate port connections"""
        # Build port lookup table
        port_lookup = {}  # instance.port -> Port object
        
        for inst_config in instances:
            if '_parsed_module' in inst_config:
                module = inst_config['_parsed_module']
                instance_name = inst_config['instance_name']
                
                for port in module.ports:
                    port_key = f"{instance_name}.{port.name}"
                    port_lookup[port_key] = port
        
        # Validate instance-to-top connections
        for inst_port, top_port in instance_to_top.items():
            config_line = f"{inst_port} -> {top_port}"
            
            # Extract base port name (without bit ranges)
            base_inst_port = inst_port.split('[')[0]
            
            if base_inst_port not in port_lookup:
                self.error_reporter.add_error("PORT_NOT_FOUND", 
                                            f"Port '{base_inst_port}' not found", 
                                            config_line)
                continue
            
            port = port_lookup[base_inst_port]
            
            # Check for special connections
            if top_port in ['TIE0', 'TIE1', 'FLOAT']:
                if port.direction != 'input':
                    self.error_reporter.add_error("INVALID_TIE_CONNECTION", 
                                                f"Cannot tie {port.direction} port '{inst_port}' to '{top_port}'", 
                                                config_line)
        
        # Validate instance-to-instance connections
        for connection in instance_connections:
            source = connection.get('source', '')
            target = connection.get('target', '')
            config_line = f"{source} -> {target}"
            
            # Extract base port names
            base_source = source.split('[')[0]
            base_target = target.split('[')[0]
            
            # Check if ports exist
            if base_source not in port_lookup:
                self.error_reporter.add_error("PORT_NOT_FOUND", 
                                            f"Source port '{base_source}' not found", 
                                            config_line)
                continue
            
            if base_target not in port_lookup and target not in ['TIE0', 'TIE1', 'FLOAT']:
                self.error_reporter.add_error("PORT_NOT_FOUND", 
                                            f"Target port '{base_target}' not found", 
                                            config_line)
                continue
            
            source_port = port_lookup[base_source]
            
            # Check for invalid connections
            if target not in ['TIE0', 'TIE1', 'FLOAT']:
                target_port = port_lookup[base_target]
                
                # Check direction compatibility
                if source_port.direction == 'input' and target_port.direction == 'input':
                    self.error_reporter.add_error("INVALID_CONNECTION", 
                                                f"Cannot connect input '{source}' to input '{target}'", 
                                                config_line)
                elif source_port.direction == 'output' and target_port.direction == 'output':
                    self.error_reporter.add_error("INVALID_CONNECTION", 
                                                f"Cannot connect output '{source}' to output '{target}'", 
                                                config_line)
                elif source_port.direction != 'output' and target_port.direction != 'input':
                    self.error_reporter.add_warning("QUESTIONABLE_CONNECTION", 
                                                   f"Questionable connection: {source_port.direction} '{source}' to {target_port.direction} '{target}'", 
                                                   config_line)
            else:
                # Tie connection
                if source_port.direction != 'input':
                    self.error_reporter.add_error("INVALID_TIE_CONNECTION", 
                                                f"Cannot tie {source_port.direction} port '{source}' to '{target}'", 
                                                config_line)
    
    def _extract_port_and_range(self, port_spec: str) -> Tuple[str, Optional[str]]:
        """Extract port name and bit range from port specification"""
        if '[' in port_spec and ']' in port_spec:
            # Has bit range
            port_name = port_spec.split('[')[0]
            bit_range = '[' + port_spec.split('[')[1]
            return port_name, bit_range
        else:
            return port_spec, None
    
    def _generate_wire_name(self, source_spec: str, target_spec: str) -> str:
        """Generate wire name showing source->target direction with w_ prefix"""
        # Extract port names and ranges
        source_port, source_range = self._extract_port_and_range(source_spec)
        target_port, target_range = self._extract_port_and_range(target_spec)
        
        # Clean up port names
        source_clean = source_port.replace('.', '_')
        target_clean = target_port.replace('.', '_')
        
        # Add range information if present
        range_suffix = ""
        if source_range and target_range:
            # Both have ranges - show mapping
            source_bits = source_range.replace('[', '').replace(']', '').replace(':', '_')
            target_bits = target_range.replace('[', '').replace(']', '').replace(':', '_')
            range_suffix = f"_{source_bits}_to_{target_bits}"
        elif source_range:
            # Only source has range
            source_bits = source_range.replace('[', '').replace(']', '').replace(':', '_')
            range_suffix = f"_{source_bits}"
        elif target_range:
            # Only target has range
            target_bits = target_range.replace('[', '').replace(']', '').replace(':', '_')
            range_suffix = f"_to_{target_bits}"
        
        return f"w_{source_clean}_to_{target_clean}{range_suffix}"
    
    def _get_port_width_value(self, width_str: str) -> str:
        """Extract the bit width value from port width string like '[7:0]' -> '8' """
        if not width_str:
            return "1"
        
        # Remove brackets
        width_clean = width_str.strip('[]')
        
        # Handle range format like "7:0"
        if ':' in width_clean:
            parts = width_clean.split(':')
            try:
                msb = int(parts[0])
                lsb = int(parts[1])
                return str(msb - lsb + 1)
            except:
                return "1"
        else:
            # Single number, assume it's MSB with LSB=0
            try:
                msb = int(width_clean)
                return str(msb + 1)
            except:
                return "1"
    
    def _generate_connection_name(self, connection_spec: str) -> str:
        """Generate connection name handling special cases and bit ranges"""
        # Handle special connections
        if connection_spec in ['TIE0', 'TIE1', 'FLOAT']:
            if connection_spec == 'TIE0':
                return "1'b0"
            elif connection_spec == 'TIE1':
                return "1'b1"
            elif connection_spec == 'FLOAT':
                return "1'bz"
        
        # Handle bit ranges
        if '[' in connection_spec and ']' in connection_spec:
            # This is a partial connection, use the full specification
            return f"w_{connection_spec.replace('.', '_')}"
        
        # Normal connection
        return f"w_{connection_spec.replace('.', '_')}"
    
    def _analyze_port_partial_connections(self, instance: Instance, port: Port, instance_to_top: Dict[str, str], instance_connections: List[Dict]) -> List[str]:
        """Analyze partial connections for a port and return unconnected bit ranges"""
        if not port.width:
            return []  # Not a multibit port
        
        # Parse port width to get bit range
        width_match = re.match(r'\[(\d+):(\d+)\]', port.width)
        if not width_match:
            return []  # Cannot parse width
        
        msb = int(width_match.group(1))
        lsb = int(width_match.group(2))
        
        # Track which bits are connected
        connected_bits = set()
        
        # Check instance-to-top connections
        inst_port_name = f"{instance.instance_name}.{port.name}"
        for mapped_port, top_port_name in instance_to_top.items():
            if mapped_port.startswith(inst_port_name):
                # Extract bit range from mapped port
                if '[' in mapped_port and ']' in mapped_port:
                    # Handle both [msb:lsb] and [bit] formats
                    range_match = re.search(r'\[(\d+):(\d+)\]', mapped_port)
                    single_bit_match = re.search(r'\[(\d+)\]', mapped_port)
                    
                    if range_match:
                        range_msb = int(range_match.group(1))
                        range_lsb = int(range_match.group(2))
                        for bit in range(range_lsb, range_msb + 1):
                            connected_bits.add(bit)
                    elif single_bit_match:
                        bit = int(single_bit_match.group(1))
                        connected_bits.add(bit)
                elif mapped_port == inst_port_name:
                    # Full port connection
                    for bit in range(lsb, msb + 1):
                        connected_bits.add(bit)
        
        # Check instance-to-instance connections
        for connection in instance_connections:
            source_port, source_range = self._extract_port_and_range(connection['source'])
            target_port, target_range = self._extract_port_and_range(connection['target'])
            
            if source_port == inst_port_name:
                if source_range:
                    # Handle both [msb:lsb] and [bit] formats
                    range_match = re.search(r'\[(\d+):(\d+)\]', source_range)
                    single_bit_match = re.search(r'\[(\d+)\]', source_range)
                    
                    if range_match:
                        range_msb = int(range_match.group(1))
                        range_lsb = int(range_match.group(2))
                        for bit in range(range_lsb, range_msb + 1):
                            connected_bits.add(bit)
                    elif single_bit_match:
                        bit = int(single_bit_match.group(1))
                        connected_bits.add(bit)
                else:
                    # Full port connection
                    for bit in range(lsb, msb + 1):
                        connected_bits.add(bit)
            elif target_port == inst_port_name:
                if target_range:
                    # Handle both [msb:lsb] and [bit] formats
                    range_match = re.search(r'\[(\d+):(\d+)\]', target_range)
                    single_bit_match = re.search(r'\[(\d+)\]', target_range)
                    
                    if range_match:
                        range_msb = int(range_match.group(1))
                        range_lsb = int(range_match.group(2))
                        for bit in range(range_lsb, range_msb + 1):
                            connected_bits.add(bit)
                    elif single_bit_match:
                        bit = int(single_bit_match.group(1))
                        connected_bits.add(bit)
                else:
                    # Full port connection
                    for bit in range(lsb, msb + 1):
                        connected_bits.add(bit)
        
        # Find unconnected bit ranges
        unconnected_ranges = []
        all_bits = set(range(lsb, msb + 1))
        unconnected_bits = sorted(all_bits - connected_bits)
        
        # Group consecutive unconnected bits into ranges
        if unconnected_bits:
            range_start = unconnected_bits[0]
            range_end = unconnected_bits[0]
            
            for bit in unconnected_bits[1:]:
                if bit == range_end + 1:
                    range_end = bit
                else:
                    # End of current range, add it
                    if range_start == range_end:
                        unconnected_ranges.append(f"[{range_start}]")
                    else:
                        unconnected_ranges.append(f"[{range_end}:{range_start}]")
                    range_start = bit
                    range_end = bit
            
            # Add final range
            if range_start == range_end:
                unconnected_ranges.append(f"[{range_start}]")
            else:
                unconnected_ranges.append(f"[{range_end}:{range_start}]")
        
        return unconnected_ranges
    
    def _extract_parameters_from_module(self, file_path: str) -> Dict[str, str]:
        """Extract all parameter and localparam values from module, handling dependencies"""
        try:
            with open(file_path, 'r') as f:
                content = f.read()
        except FileNotFoundError:
            return {}
        
        # Remove comments
        content = re.sub(r'//.*', '', content)
        content = re.sub(r'/\*.*?\*/', '', content, flags=re.DOTALL)
        
        # Find module declaration with parameters
        module_match = self.parser._find_module_declaration(content)
        if not module_match:
            # Try to find module declaration manually as fallback
            module_fallback_match = re.search(r'module\s+\w+', content)
            if not module_fallback_match:
                return {}
        
        # Extract parameter declarations from module header and body
        param_dict = {}
        clean_content = re.sub(r'\s+', ' ', content)
        
        # Find parameters in module declaration header
        param_section_match = re.search(r'module\s+\w+\s*#\s*\((.*?)\)\s*\(', clean_content, re.DOTALL)
        if param_section_match:
            param_section = param_section_match.group(1)
            
            # Enhanced parameter parsing using manual parsing to handle complex expressions
            # Split by commas first, then parse each declaration
            param_dict.update(self._parse_parameter_declarations(param_section))
        
        # Also find parameters in module body (for cases where they are declared separately)
        module_body_match = re.search(r'module\s+\w+[^;]*;\s*(.*?)\s*endmodule', clean_content, re.DOTALL)
        if module_body_match:
            module_body = module_body_match.group(1)
            
            # Find parameter declarations in module body - improved to handle complex expressions
            body_param_pattern = r'(parameter|localparam)\s+(\w+)\s*=\s*([^;]+);'
            body_matches = re.findall(body_param_pattern, module_body, re.DOTALL)
            
            for param_type, param_name, param_value in body_matches:
                param_value = param_value.strip()
                param_dict[param_name.strip()] = param_value
        
        # Store original expressions for later dependency resolution
        self._original_expressions = {}
        for param_name, param_value in param_dict.items():
            self._original_expressions[param_name] = param_value
        
        # Improved parameter dependency resolution with better ordering
        resolved_params = self._resolve_parameter_dependencies_improved(param_dict)
        
        return resolved_params
    
    def _parse_parameter_declarations(self, param_section: str) -> Dict[str, str]:
        """Parse parameter declarations from a section, handling complex expressions properly"""
        param_dict = {}
        
        # Remove extra spaces
        param_section = param_section.strip()
        
        # Manual parsing to handle complex expressions with nested parentheses
        i = 0
        while i < len(param_section):
            # Skip whitespace
            while i < len(param_section) and param_section[i].isspace():
                i += 1
            
            if i >= len(param_section):
                break
                
            # Look for parameter or localparam keyword
            if param_section[i:].startswith('parameter'):
                param_type = 'parameter'
                i += 9  # len('parameter')
            elif param_section[i:].startswith('localparam'):
                param_type = 'localparam'
                i += 10  # len('localparam')
            else:
                # Skip unexpected characters
                i += 1
                continue
            
            # Skip whitespace
            while i < len(param_section) and param_section[i].isspace():
                i += 1
            
            # Extract parameter name
            param_name_start = i
            while i < len(param_section) and (param_section[i].isalnum() or param_section[i] == '_'):
                i += 1
            
            if param_name_start == i:
                continue  # No valid parameter name found
                
            param_name = param_section[param_name_start:i]
            
            # Skip whitespace and '='
            while i < len(param_section) and param_section[i].isspace():
                i += 1
            
            if i >= len(param_section) or param_section[i] != '=':
                continue  # No '=' found
                
            i += 1  # Skip '='
            
            # Skip whitespace
            while i < len(param_section) and param_section[i].isspace():
                i += 1
            
            # Extract parameter value until next parameter declaration or end
            param_value_start = i
            paren_depth = 0
            
            while i < len(param_section):
                char = param_section[i]
                
                if char == '(':
                    paren_depth += 1
                elif char == ')':
                    paren_depth -= 1
                elif char == ',' and paren_depth == 0:
                    # Found comma at top level, this ends the parameter value
                    break
                    
                i += 1
            
            param_value = param_section[param_value_start:i].strip()
            
            # Remove trailing comma if present
            param_value = re.sub(r',$', '', param_value)
            
            param_dict[param_name] = param_value
            
            # Skip the comma if present
            if i < len(param_section) and param_section[i] == ',':
                i += 1
        
        return param_dict
    
    def _resolve_parameter_dependencies_improved(self, param_dict: Dict[str, str]) -> Dict[str, str]:
        """Improved parameter dependency resolution with topological sorting"""
        # Create dependency graph
        dependencies = {}
        for param_name, param_value in param_dict.items():
            deps = set()
            for other_param in param_dict.keys():
                if other_param != param_name and re.search(r'\b' + other_param + r'\b', param_value):
                    deps.add(other_param)
            dependencies[param_name] = deps
        
        # Topological sort to resolve dependencies in correct order
        resolved_params = {}
        visited = set()
        temp_visited = set()
        
        def resolve_param(param_name):
            if param_name in temp_visited:
                # Circular dependency - keep original expression
                resolved_params[param_name] = param_dict[param_name]
                return
            if param_name in visited:
                return
            
            temp_visited.add(param_name)
            
            # First resolve all dependencies
            for dep in dependencies.get(param_name, set()):
                if dep not in visited:
                    resolve_param(dep)
            
            # Now resolve this parameter
            param_value = param_dict[param_name]
            
            # Substitute resolved parameters
            for dep in dependencies.get(param_name, set()):
                if dep in resolved_params:
                    param_value = re.sub(r'\b' + dep + r'\b', resolved_params[dep], param_value)
            
            # Try to evaluate the expression
            try:
                # Handle conditional expressions (ternary operator)
                if '?' in param_value and ':' in param_value:
                    # For simple conditional expressions, try to evaluate
                    # Handle both (condition) ? true : false and condition ? true : false
                    ternary_match = re.match(r'^\s*\(?([^)]+)\)?\s*\?\s*([^:]+)\s*:\s*(.+)$', param_value)
                    if ternary_match:
                        condition, true_val, false_val = ternary_match.groups()
                        # Try to evaluate condition
                        try:
                            # Replace system functions with placeholders for evaluation
                            eval_condition = condition.strip()
                            # Handle $clog2 function properly
                            def replace_clog2(match):
                                arg = match.group(1).strip()
                                try:
                                    # Try to evaluate the argument
                                    arg_val = eval(arg)
                                    import math
                                    return str(int(math.ceil(math.log2(arg_val))) if arg_val > 0 else 1)
                                except:
                                    return '6'  # Default placeholder
                            eval_condition = re.sub(r'\$clog2\(([^)]+)\)', replace_clog2, eval_condition)
                            eval_condition = re.sub(r'<<', '**', eval_condition)  # Bit shift to power
                            
                            if eval(eval_condition):
                                param_value = true_val.strip()
                            else:
                                param_value = false_val.strip()
                            
                            # If the result still contains expressions, try to evaluate them
                            if '$clog2' in param_value:
                                param_value = re.sub(r'\$clog2\(([^)]+)\)', replace_clog2, param_value)
                            if re.match(r'^[\d\+\-\*\/\(\)\s]+$', param_value):
                                param_value = str(eval(param_value))
                                
                        except:
                            # Keep original expression if evaluation fails
                            pass
                    
                    # Update resolved_params with the final value
                    resolved_params[param_name] = param_value
                
                # Handle arithmetic expressions with basic operators
                elif re.match(r'^[\d\+\-\*\/\(\)\s<<>>]+$', param_value):
                    # Replace bit shift with power for evaluation
                    eval_expr = param_value.replace('<<', '**')
                    eval_expr = re.sub(r'(\d+)\s*\*\*\s*(\d+)', lambda m: str(1 << int(m.group(2))), eval_expr)
                    resolved_params[param_name] = str(eval(eval_expr))
                # Handle system functions
                elif '$clog2' in param_value:
                    # Handle $clog2 function
                    def replace_clog2(match):
                        arg = match.group(1).strip()
                        try:
                            # Try to evaluate the argument
                            arg_val = eval(arg)
                            import math
                            return str(int(math.ceil(math.log2(arg_val))) if arg_val > 0 else 1)
                        except:
                            return '6'  # Default placeholder
                    eval_expr = re.sub(r'\$clog2\(([^)]+)\)', replace_clog2, param_value)
                    # Try to evaluate the result
                    try:
                        resolved_params[param_name] = str(eval(eval_expr))
                    except:
                        resolved_params[param_name] = param_value
                else:
                    # Keep as-is for complex expressions
                    resolved_params[param_name] = param_value
            except:
                # If evaluation fails, keep the original expression
                resolved_params[param_name] = param_value
            
            temp_visited.remove(param_name)
            visited.add(param_name)
        
        # Resolve all parameters
        for param_name in param_dict.keys():
            if param_name not in visited:
                resolve_param(param_name)
        
        return resolved_params
    
    def _resolve_parameter_dependencies(self, param_dict: Dict[str, str]) -> Dict[str, str]:
        """Resolve parameter dependencies in parameter dictionary using original expressions"""
        # Make a copy to avoid modifying original
        resolved_params = param_dict.copy()
        
        # Use original expressions if available for local parameters that need re-evaluation
        if hasattr(self, '_original_expressions'):
            for param_name, original_expr in self._original_expressions.items():
                # Check if this is a local parameter expression that references other parameters
                if any(other_param in original_expr for other_param in resolved_params.keys() if other_param != param_name):
                    # This expression references other parameters, use the original
                    resolved_params[param_name] = original_expr
        
        # Resolve parameter dependencies (local parameters that reference other parameters)
        max_iterations = 10  # Prevent infinite loops
        for _ in range(max_iterations):
            changes_made = False
            for param_name, param_value in resolved_params.items():
                # Check if this parameter value references other parameters
                for other_param, other_value in resolved_params.items():
                    if other_param != param_name and re.search(r'\b' + other_param + r'\b', param_value):
                        # Replace parameter reference with its value
                        new_value = re.sub(r'\b' + other_param + r'\b', other_value, param_value)
                        if new_value != param_value:
                            resolved_params[param_name] = new_value
                            changes_made = True
            
            if not changes_made:
                break
        
        # Evaluate arithmetic expressions
        for param_name, param_value in resolved_params.items():
            try:
                if re.match(r'^[\d\+\-\*\/\(\)\s]+$', param_value):
                    resolved_params[param_name] = str(eval(param_value))
            except:
                pass
        
        return resolved_params
    
    def _substitute_parameters(self, width_str: str, param_values: Dict[str, str]) -> str:
        """Substitute parameter values in width string"""
        if not width_str:
            return width_str
        
        # Remove brackets first if they exist
        original_has_brackets = width_str.startswith('[') and width_str.endswith(']')
        if original_has_brackets:
            width_str = width_str[1:-1]  # Remove [ and ]
        
        # Replace parameter names with actual values
        for param_name, param_value in param_values.items():
            # Replace parameter name with value
            width_str = re.sub(r'\b' + param_name + r'\b', param_value, width_str)
        
        # Evaluate expressions in width specification
        try:
            # Handle [msb:lsb] patterns first
            if ':' in width_str:
                parts = width_str.split(':')
                if len(parts) == 2:
                    try:
                        # Evaluate both parts if they contain arithmetic
                        msb_str = parts[0].strip()
                        lsb_str = parts[1].strip()
                        
                        if re.match(r'^[\d\+\-\*\/\(\)\s]+$', msb_str):
                            msb = eval(msb_str)
                        else:
                            msb = msb_str
                            
                        if re.match(r'^[\d\+\-\*\/\(\)\s]+$', lsb_str):
                            lsb = eval(lsb_str)
                        else:
                            lsb = lsb_str
                            
                        width_str = f"{msb}:{lsb}"
                    except:
                        pass
            elif re.match(r'^[\d\+\-\*\/\(\)\s]+$', width_str):
                # Process single expressions
                width_str = str(eval(width_str))
        except:
            pass
        
        # Add brackets back if they were originally there
        if original_has_brackets:
            width_str = f"[{width_str}]"
        
        return width_str
    
    def _format_port_declarations(self, ports: List[Port]) -> List[str]:
        """Format port declarations with proper alignment"""
        if not ports:
            return []
        
        # Calculate maximum widths for alignment
        max_direction_width = max(len(port.direction) for port in ports)
        
        # Calculate the position where [ should start (after direction + wire + spaces)
        bracket_position = 4 + max_direction_width + 2 + 4 + 2  # indent + direction + spaces + wire + spaces
        
        # Find the maximum width needed for the width part (including brackets)
        max_width_with_brackets = 0
        for port in ports:
            if port.width:
                max_width_with_brackets = max(max_width_with_brackets, len(port.width))
        
        # Calculate where signal names should start
        signal_name_position = bracket_position + max_width_with_brackets + 4
        
        formatted_ports = []
        for port in ports:
            direction = port.direction.ljust(max_direction_width)
            
            # Build the line with precise positioning
            line = f"    {direction}  wire  "
            
            if port.width:
                # Add width at the correct bracket position
                current_pos = len(line)
                spaces_to_bracket = bracket_position - current_pos
                line += " " * spaces_to_bracket + port.width
                
                # Add spaces to align signal name
                current_pos = len(line)
                spaces_to_signal = signal_name_position - current_pos
                line += " " * spaces_to_signal + port.name
            else:
                # No width, just align signal name
                current_pos = len(line)
                spaces_to_signal = signal_name_position - current_pos
                line += " " * spaces_to_signal + port.name
            
            formatted_ports.append(line)
        
        return formatted_ports
    
    def _format_instance_connections(self, instance: Instance, port_connections: List[str]) -> List[str]:
        """Format instance port connections with proper alignment"""
        if not port_connections:
            return []
        
        # Extract port names and connection names for alignment calculation
        port_info = []
        for connection in port_connections:
            # Parse connection string: "        .port_name(connection_name)"
            match = re.match(r'\s*\.(\w+)\((.+)\)', connection)
            if match:
                port_name = match.group(1)
                conn_name = match.group(2)
                port_info.append((port_name, conn_name))
        
        if not port_info:
            return port_connections
        
        # Calculate maximum port name width for alignment of ( position
        max_port_width = max(len(port_name) for port_name, _ in port_info)
        
        # Calculate the position where ( should start
        paren_position = 8 + 1 + max_port_width  # indent + . + port_name
        
        # Format connections with alignment
        formatted_connections = []
        for port_name, conn_name in port_info:
            # Build the line with precise positioning
            line = f"        .{port_name}"
            
            # Add spaces to align ( position
            current_pos = len(line)
            spaces_to_paren = paren_position - current_pos
            line += " " * spaces_to_paren + f"({conn_name})"
            
            formatted_connections.append(line)
        
        return formatted_connections
    
    def _format_wire_declarations(self, wire_dict: Dict[str, Optional[str]]) -> List[str]:
        """Format wire declarations with proper alignment"""
        if not wire_dict:
            return []
        
        # Find the maximum width needed for the width part (including brackets)
        max_width_with_brackets = 0
        for width in wire_dict.values():
            if width:
                max_width_with_brackets = max(max_width_with_brackets, len(width))
        
        # Calculate the position where [ should start (after wire + spaces)
        bracket_position = 4 + 4 + 2  # indent + wire + spaces
        
        # Calculate where signal names should start
        signal_name_position = bracket_position + max_width_with_brackets + 4
        
        formatted_wires = []
        for wire_name, width in sorted(wire_dict.items()):
            # Build the line with precise positioning
            line = f"    wire  "
            
            if width:
                # Ensure width is properly formatted
                if not width.startswith('['):
                    width = f"[{width}]"
                
                # Add width at the correct bracket position
                current_pos = len(line)
                spaces_to_bracket = bracket_position - current_pos
                line += " " * spaces_to_bracket + width
                
                # Add spaces to align signal name
                current_pos = len(line)
                spaces_to_signal = signal_name_position - current_pos
                line += " " * spaces_to_signal + wire_name + ";"
            else:
                # No width, just align signal name
                current_pos = len(line)
                spaces_to_signal = signal_name_position - current_pos
                line += " " * spaces_to_signal + wire_name + ";"
            
            formatted_wires.append(line)
        
        return formatted_wires
    
    def _resolve_file_path(self, file_path: str) -> Optional[str]:
        """Resolve file path by checking multiple locations"""
        import os
        
        # Try current working directory
        if os.path.exists(file_path):
            return file_path
        
        # Try script directory (where verilog_wrapper_generator.py is located)
        script_dir = os.path.dirname(os.path.abspath(__file__))
        script_path = os.path.join(script_dir, file_path)
        if os.path.exists(script_path):
            return script_path
        
        # Try parent directory of current working directory
        parent_dir = os.path.dirname(os.getcwd())
        parent_path = os.path.join(parent_dir, file_path)
        if os.path.exists(parent_path):
            return parent_path
        
        return None
    
    def _format_simple_wire_declarations(self, wire_list: List[str]) -> List[str]:
        """Format simple wire declarations with proper alignment"""
        if not wire_list:
            return []
        
        # For simple wires, all are assumed to be single-bit
        # Calculate the position where signal names should start
        signal_name_position = 4 + 4 + 4  # indent + wire + spaces
        
        formatted_wires = []
        for wire_name in sorted(wire_list):
            # Build the line with precise positioning
            line = f"    wire  "
            
            # Add spaces to align signal name
            current_pos = len(line)
            spaces_to_signal = signal_name_position - current_pos
            line += " " * spaces_to_signal + wire_name + ";"
            
            formatted_wires.append(line)
        
        return formatted_wires
    
    def _generate_wrapper_code_advanced(self, top_module_name: str, top_module_parameters: Dict[str, str], instances: List[Instance], 
                                      top_ports: List[Port], instance_connections: List[Dict], instance_to_top: Dict[str, str], instance_export_ports: List[Dict] = None) -> str:
        """Generate wrapper code with advanced configuration"""
        lines = []
        
        # Initialize unconnected port tracking
        unconnected_inputs = []
        unconnected_outputs = []
        unconnected_inouts = []
        
        # Collect all parameters needed for port widths from instances
        all_instance_params = {}
        for instance in instances:
            module_params = self._extract_parameters_from_module(instance.module.file_path)
            # Create instance-specific parameter dict with overrides
            instance_params = module_params.copy()
            if instance.parameters:
                for param_name, param_value in instance.parameters.items():
                    instance_params[param_name] = param_value
            # Re-evaluate local parameters with instance-specific values
            instance_params = self._resolve_parameter_dependencies_improved(instance_params)
            all_instance_params.update(instance_params)
        
        # Find parameters referenced in port widths
        port_width_params = set()
        for port in top_ports:
            if port.width and port.width.strip():
                # Find parameter references in width specification
                width_text = port.width.strip('[]')
                # Find all identifiers that could be parameters
                param_refs = re.findall(r'\b[A-Z_][A-Z0-9_]*\b', width_text)
                for param_ref in param_refs:
                    if param_ref in all_instance_params:
                        port_width_params.add(param_ref)
        
        # Add missing parameters to top module parameters
        enhanced_top_params = top_module_parameters.copy() if top_module_parameters else {}
        for param_name in port_width_params:
            if param_name not in enhanced_top_params and param_name in all_instance_params:
                # Use the evaluated value instead of the original expression for port width parameters
                param_value = all_instance_params[param_name]
                # If it's a simple numeric value, use it directly
                try:
                    # Try to convert to int first, then to string
                    if isinstance(param_value, (int, float)):
                        enhanced_top_params[param_name] = str(int(param_value))
                    elif param_value.isdigit():
                        enhanced_top_params[param_name] = param_value
                    else:
                        enhanced_top_params[param_name] = param_value
                except:
                    enhanced_top_params[param_name] = param_value
        
        # Module declaration with parameters
        if enhanced_top_params:
            # Generate parameter declaration
            param_list = []
            for param_name, param_value in enhanced_top_params.items():
                param_list.append(f"parameter {param_name} = {param_value}")
            newline = '\n'
            param_str = f" #({newline}    {f',{newline}    '.join(param_list)}{newline})"
            lines.append(f"module {top_module_name}{param_str} (")
        else:
            lines.append(f"module {top_module_name} (")
        
        # Top-level ports with proper formatting
        if top_ports:
            formatted_port_lines = self._format_port_declarations(top_ports)
            lines.append(",\n".join(formatted_port_lines))
        
        lines.append(");")
        lines.append("")
        
        # Generate internal wires for instance connections
        internal_wires = {}  # wire_name -> width
        top_port_names = {port.name for port in top_ports}
        
        # Collect all connection wires with their widths
        # First collect parameter values from all instances with proper override handling
        param_values = {}
        for instance in instances:
            # Extract base parameters from module file
            module_params = self._extract_parameters_from_module(instance.module.file_path)
            
            # Create instance-specific parameter dict with overrides
            instance_params = module_params.copy()
            if instance.parameters:
                for param_name, param_value in instance.parameters.items():
                    instance_params[param_name] = param_value
            
            # Re-evaluate local parameters with instance-specific values
            instance_params = self._resolve_parameter_dependencies_improved(instance_params)
            
            # Update global parameter values
            param_values.update(instance_params)
        
        for connection in instance_connections:
            source = connection['source']
            target = connection['target']
            
            # Skip special connections
            if target in ['TIE0', 'TIE1', 'FLOAT'] or source in ['TIE0', 'TIE1', 'FLOAT']:
                continue
            
            # Generate wire name based on connection
            wire_name = self._generate_wire_name(source, target)
            
            # Find the port width from the source module
            if '.' in source:
                source_port, source_range = self._extract_port_and_range(source)
                for instance in instances:
                    if source_port.startswith(f"{instance.instance_name}."):
                        # Get instance-specific parameter values
                        module_params = self._extract_parameters_from_module(instance.module.file_path)
                        instance_params = module_params.copy()
                        if instance.parameters:
                            for param_name, param_value in instance.parameters.items():
                                instance_params[param_name] = param_value
                        instance_params = self._resolve_parameter_dependencies(instance_params)
                        
                        port_name = source_port.split('.', 1)[1]
                        for port in instance.module.ports:
                            if port.name == port_name:
                                # Use partial width if range specified
                                if source_range:
                                    # Calculate partial width from range
                                    internal_wires[wire_name] = source_range
                                else:
                                    # Substitute instance-specific parameter values in width
                                    width = self._substitute_parameters(port.width, instance_params) if port.width else None
                                    internal_wires[wire_name] = width
                                break
                        break
        
        # Add internal wires only for ports that actually need them
        for instance in instances:
            # Get instance-specific parameter values
            module_params = self._extract_parameters_from_module(instance.module.file_path)
            instance_params = module_params.copy()
            if instance.parameters:
                for param_name, param_value in instance.parameters.items():
                    instance_params[param_name] = param_value
            instance_params = self._resolve_parameter_dependencies(instance_params)
            
            for port in instance.module.ports:
                inst_port = f"{instance.instance_name}.{port.name}"
                wire_name = f"w_{instance.instance_name}_{port.name}"
                
                # Check if this port needs a wire
                needs_wire = False
                is_directly_connected_to_top = False
                
                # Check if port is directly connected to top-level port (no wire needed)
                for mapped_port, top_port in instance_to_top.items():
                    if mapped_port.split('[')[0] == inst_port:
                        if top_port not in ['TIE0', 'TIE1', 'FLOAT'] and '[' not in mapped_port:
                            # Direct connection to top-level port, no wire needed
                            is_directly_connected_to_top = True
                            break
                        else:
                            # TIE connection or partial connection, wire needed
                            needs_wire = True
                            break
                
                # Check if port is used in instance-to-instance connections
                if not is_directly_connected_to_top:
                    for connection in instance_connections:
                        if connection['source'].split('[')[0] == inst_port or connection['target'].split('[')[0] == inst_port:
                            needs_wire = True
                            break
                
                # Check if port has partial bit connections
                if not is_directly_connected_to_top and not needs_wire:
                    for mapped_port in instance_to_top.keys():
                        if mapped_port.split('[')[0] == inst_port and '[' in mapped_port:
                            needs_wire = True
                            break
                
                # Add wire only if needed
                if needs_wire and wire_name not in top_port_names:
                    # Substitute instance-specific parameter values in width
                    width = self._substitute_parameters(port.width, instance_params) if port.width else None
                    internal_wires[wire_name] = width
                
                # Don't create unconnected wires - handle unconnected ports directly in instance connections
        
        # Generate wire declarations
        if internal_wires:
            lines.append("// Internal wires")
            formatted_wires = self._format_wire_declarations(internal_wires)
            lines.extend(formatted_wires)
            lines.append("")
        
        # Generate tie connections
        tie_connections = []
        for connection in instance_connections:
            if connection['target'] in ['TIE0', 'TIE1', 'FLOAT']:
                tie_connections.append(connection)
        
        for inst_port, top_port in instance_to_top.items():
            if top_port in ['TIE0', 'TIE1', 'FLOAT']:
                tie_connections.append({'source': inst_port, 'target': top_port})
        
        # Generate tie wire assignments and partial connections
        if tie_connections:
            lines.append("// Tie connections")
            for connection in tie_connections:
                source_port, source_range = self._extract_port_and_range(connection['source'])
                
                # Generate descriptive TIE wire names
                if connection['target'] == 'TIE0':
                    wire_name = f"w_{source_port.replace('.', '_')}_tied_to_0"
                elif connection['target'] == 'TIE1':
                    wire_name = f"w_{source_port.replace('.', '_')}_tied_to_1"
                elif connection['target'] == 'FLOAT':
                    wire_name = f"w_{source_port.replace('.', '_')}_float"
                else:
                    wire_name = f"w_{source_port.replace('.', '_')}"
                
                # Handle bit range for TIE assignments
                if source_range:
                    # Extract bit width for proper assignment
                    range_match = re.search(r'\[(\d+):(\d+)\]', source_range)
                    single_bit_match = re.search(r'\[(\d+)\]', source_range)
                    
                    if range_match:
                        msb = int(range_match.group(1))
                        lsb = int(range_match.group(2))
                        width = msb - lsb + 1
                        
                        if connection['target'] == 'TIE0':
                            lines.append(f"    assign {wire_name} = {width}'b{'0' * width};")
                        elif connection['target'] == 'TIE1':
                            lines.append(f"    assign {wire_name} = {width}'b{'1' * width};")
                        elif connection['target'] == 'FLOAT':
                            lines.append(f"    assign {wire_name} = {width}'bz;")
                    elif single_bit_match:
                        if connection['target'] == 'TIE0':
                            lines.append(f"    assign {wire_name} = 1'b0;")
                        elif connection['target'] == 'TIE1':
                            lines.append(f"    assign {wire_name} = 1'b1;")
                        elif connection['target'] == 'FLOAT':
                            lines.append(f"    assign {wire_name} = 1'bz;")
                else:
                    # Single bit assignment
                    if connection['target'] == 'TIE0':
                        lines.append(f"    assign {wire_name} = 1'b0;")
                    elif connection['target'] == 'TIE1':
                        lines.append(f"    assign {wire_name} = 1'b1;")
                    elif connection['target'] == 'FLOAT':
                        lines.append(f"    assign {wire_name} = 1'bz;")
            lines.append("")
        
        # Generate partial bit connections
        partial_connections = []
        for inst_port, top_port in instance_to_top.items():
            if '[' in inst_port or '[' in top_port:
                if top_port not in ['TIE0', 'TIE1', 'FLOAT']:
                    partial_connections.append({'source': inst_port, 'target': top_port})
        
        for connection in instance_connections:
            if ('[' in connection['source'] or '[' in connection['target']) and connection['target'] not in ['TIE0', 'TIE1', 'FLOAT']:
                partial_connections.append(connection)
        
        if partial_connections:
            lines.append("// Partial bit connections")
            for connection in partial_connections:
                source_port, source_range = self._extract_port_and_range(connection['source'])
                target_port, target_range = self._extract_port_and_range(connection['target'])
                
                # For instance-to-top connections, use the target name directly
                if '.' not in connection['target']:
                    # This is a top-level port connection
                    source_wire = f"w_{source_port.replace('.', '_')}"
                    target_wire = connection['target']
                else:
                    # This is an instance-to-instance connection
                    source_wire = f"w_{source_port.replace('.', '_')}"
                    target_wire = f"w_{target_port.replace('.', '_')}"
                
                if source_range and target_range:
                    lines.append(f"    assign {target_wire}{target_range} = {source_wire}{source_range};")
                elif source_range:
                    lines.append(f"    assign {target_wire} = {source_wire}{source_range};")
                elif target_range:
                    lines.append(f"    assign {target_wire}{target_range} = {source_wire};")
            lines.append("")
        
        # Instance declarations
        for instance in instances:
            # Generate parameter string
            param_str = ""
            if instance.parameters:
                param_list = []
                for param_name, param_value in instance.parameters.items():
                    param_list.append(f".{param_name}({param_value})")
                param_str = f" #({', '.join(param_list)})"
            
            lines.append(f"    {instance.module.name}{param_str} {instance.instance_name} (")
            
            port_connections = []
            for port in instance.module.ports:
                connection_name = None
                
                # Check if this port is exported directly
                is_exported = False
                if instance_export_ports:
                    for export_config in instance_export_ports:
                        if (export_config['instance_name'] == instance.instance_name and 
                            export_config['port_name'] == port.name):
                            connection_name = export_config['export_name']
                            is_exported = True
                            break
                
                if not is_exported:
                    # Check if connected to top port (with bit range support)
                    port_matches = [key for key in instance.port_mapping.keys() if key.split('[')[0] == port.name]
                    if port_matches:
                        # Handle partial connections
                        mapped_port = port_matches[0]
                        top_port_name = instance.port_mapping[mapped_port]
                        
                        # Check if it's a special connection
                        if top_port_name in ['TIE0', 'TIE1', 'FLOAT']:
                            if top_port_name == 'TIE0':
                                connection_name = f"w_{instance.instance_name}_{port.name}_tied_to_0"
                            elif top_port_name == 'TIE1':
                                connection_name = f"w_{instance.instance_name}_{port.name}_tied_to_1"
                            elif top_port_name == 'FLOAT':
                                connection_name = f"w_{instance.instance_name}_{port.name}_float"
                        else:
                            # Check if partial connection
                            if '[' in mapped_port:
                                connection_name = f"w_{instance.instance_name}_{port.name}"
                            else:
                                connection_name = top_port_name
                    else:
                        # Check if connected to another instance
                        inst_port = f"{instance.instance_name}.{port.name}"
                        for connection in instance_connections:
                            source_port, source_range = self._extract_port_and_range(connection['source'])
                            target_port, target_range = self._extract_port_and_range(connection['target'])
                            
                            if source_port == inst_port:
                                if connection['target'] in ['TIE0', 'TIE1', 'FLOAT']:
                                    if connection['target'] == 'TIE0':
                                        connection_name = f"w_{instance.instance_name}_{port.name}_tied_to_0"
                                    elif connection['target'] == 'TIE1':
                                        connection_name = f"w_{instance.instance_name}_{port.name}_tied_to_1"
                                    elif connection['target'] == 'FLOAT':
                                        connection_name = f"w_{instance.instance_name}_{port.name}_float"
                                else:
                                    connection_name = self._generate_wire_name(connection['source'], connection['target'])
                                break
                            elif target_port == inst_port:
                                if connection['source'] in ['TIE0', 'TIE1', 'FLOAT']:
                                    if connection['source'] == 'TIE0':
                                        connection_name = f"w_{instance.instance_name}_{port.name}_tied_to_0"
                                    elif connection['source'] == 'TIE1':
                                        connection_name = f"w_{instance.instance_name}_{port.name}_tied_to_1"
                                    elif connection['source'] == 'FLOAT':
                                        connection_name = f"w_{instance.instance_name}_{port.name}_float"
                                else:
                                    connection_name = self._generate_wire_name(connection['source'], connection['target'])
                                break
                        
                        # If not connected, assign appropriate default values based on port direction
                        if connection_name is None:
                            if port.direction == 'input':
                                # For unconnected inputs, tie to appropriate default
                                if port.width:
                                    # Multi-bit input - tie to zero
                                    width_value = self._get_port_width_value(port.width)
                                    connection_name = f"{width_value}'b0"
                                else:
                                    # Single-bit input - tie to zero
                                    connection_name = "1'b0"
                            else:
                                # For unconnected outputs/inouts, don't connect them
                                # This is valid in Verilog - unconnected output ports are left open
                                connection_name = None
                
                # Always analyze partial connections for multibit ports
                if port.width:
                    unconnected_ranges = self._analyze_port_partial_connections(instance, port, instance_to_top, instance_connections)
                    
                    # Add to unconnected ports list with bit range information
                    if unconnected_ranges:
                        for range_info in unconnected_ranges:
                            port_info = f"{instance.instance_name}.{port.name}{range_info}"
                            if port.direction == 'input':
                                unconnected_inputs.append(port_info)
                            elif port.direction == 'output':
                                unconnected_outputs.append(port_info)
                            elif port.direction == 'inout':
                                unconnected_inouts.append(port_info)
                # Skip the old unconnected logic since we handle it differently now
                
                # Add port connection only if connection_name exists
                if connection_name is not None:
                    port_connections.append(f"        .{port.name}({connection_name})")
                else:
                    # Add to unconnected list for reporting
                    port_info = f"{instance.instance_name}.{port.name}"
                    if port.direction == 'output':
                        unconnected_outputs.append(port_info)
                    elif port.direction == 'inout':
                        unconnected_inouts.append(port_info)
            
            # Format port connections with proper alignment
            formatted_connections = self._format_instance_connections(instance, port_connections)
            lines.append(",\n".join(formatted_connections))
            lines.append("    );")  
            lines.append("")
        
        lines.append("endmodule")
        
        # Generate unconnected ports report
        self._generate_unconnected_report(unconnected_inputs, unconnected_outputs, unconnected_inouts)
        
        return "\n".join(lines)
    
    def _generate_unconnected_report(self, unconnected_inputs: List[str], unconnected_outputs: List[str], unconnected_inouts: List[str]):
        """Generate unconnected ports report files"""
        import os
        
        # Create rpt directory if it doesn't exist
        rpt_dir = "./rpt"
        if not os.path.exists(rpt_dir):
            os.makedirs(rpt_dir)
        
        # Write unconnected input ports
        with open(os.path.join(rpt_dir, "Unconnected_input.list"), 'w') as f:
            f.write("# Unconnected Input Ports\n")
            f.write("# Format: instance_name.port_name\n")
            f.write("# Generated by Verilog Wrapper Generator\n\n")
            for port in sorted(unconnected_inputs):
                f.write(f"{port}\n")
        
        # Write unconnected output ports
        with open(os.path.join(rpt_dir, "Unconnected_output.list"), 'w') as f:
            f.write("# Unconnected Output Ports\n")
            f.write("# Format: instance_name.port_name\n")
            f.write("# Generated by Verilog Wrapper Generator\n\n")
            for port in sorted(unconnected_outputs):
                f.write(f"{port}\n")
        
        # Write unconnected inout ports
        with open(os.path.join(rpt_dir, "Unconnected_inout.list"), 'w') as f:
            f.write("# Unconnected Inout Ports\n")
            f.write("# Format: instance_name.port_name\n")
            f.write("# Generated by Verilog Wrapper Generator\n\n")
            for port in sorted(unconnected_inouts):
                f.write(f"{port}\n")
    
    def _generate_wrapper_code(self, top_module_name: str, instances: List[Instance], 
                             top_ports: Dict[str, Port]) -> str:
        """Generate the actual Verilog wrapper code"""
        lines = []
        
        # Initialize unconnected port tracking
        unconnected_inputs = []
        unconnected_outputs = []
        unconnected_inouts = []
        
        # Module declaration
        lines.append(f"module {top_module_name} (")
        
        # Top-level ports
        port_lines = []
        for port in top_ports.values():
            width_str = f" {port.width}" if port.width else ""
            port_lines.append(f"    {port.direction}{width_str} {port.name}")
        
        lines.append(",\n".join(port_lines))
        lines.append(");")
        lines.append("")
        
        # Internal wire declarations for unmapped ports
        internal_wires = set()
        for instance in instances:
            for port in instance.module.ports:
                if port.name not in instance.port_mapping:
                    wire_name = f"{instance.instance_name}_{port.name}"
                    internal_wires.add(wire_name)
        
        if internal_wires:
            lines.append("// Internal wires")
            formatted_wires = self._format_simple_wire_declarations(list(internal_wires))
            lines.extend(formatted_wires)
            lines.append("")
        
        # Instance declarations
        for instance in instances:
            lines.append(f"    {instance.module.name} {instance.instance_name} (")
            
            port_connections = []
            for port in instance.module.ports:
                if port.name in instance.port_mapping:
                    # Connect to top-level port
                    top_port = instance.port_mapping[port.name]
                    port_connections.append(f"        .{port.name}({top_port})")
                else:
                    # Connect to internal wire and track unconnected ports
                    wire_name = f"{instance.instance_name}_{port.name}"
                    port_connections.append(f"        .{port.name}({wire_name})")
                    
                    # Track unconnected ports for report
                    port_info = f"{instance.instance_name}.{port.name}"
                    if port.direction == 'input':
                        unconnected_inputs.append(port_info)
                    elif port.direction == 'output':
                        unconnected_outputs.append(port_info)
                    elif port.direction == 'inout':
                        unconnected_inouts.append(port_info)
            
            lines.append(",\n".join(port_connections))
            lines.append("    );")
            lines.append("")
        
        lines.append("endmodule")
        
        # Generate unconnected ports report
        self._generate_unconnected_report(unconnected_inputs, unconnected_outputs, unconnected_inouts)
        
        return "\n".join(lines)


def main():
    """Main function for command-line interface"""
    parser = argparse.ArgumentParser(description='Generate Verilog wrapper files')
    parser.add_argument('input_file', help='Input specification file (.cmd/.txt) or JSON configuration file')
    parser.add_argument('-o', '--output', help='Output file path')
    
    args = parser.parse_args()
    
    # Generate wrapper
    try:
        generator = WrapperGenerator()
        
        # Check if input is a directory (config files) or file
        if os.path.isdir(args.input_file):
            # Configuration directory
            wrapper_code = generator.generate_wrapper_from_config(args.input_file)
        elif args.input_file.endswith('.txt') or args.input_file.endswith('.cmd'):
            # Input specification file
            wrapper_code = generator.generate_wrapper_from_spec(args.input_file)
        else:
            # JSON configuration file
            try:
                with open(args.input_file, 'r') as f:
                    config = json.load(f)
                wrapper_code = generator.generate_wrapper(config)
            except json.JSONDecodeError as e:
                print(f"Error: Invalid JSON in configuration file: {e}")
                return 1
        
        # Check if wrapper generation was successful
        if not wrapper_code:
            print("Error: Wrapper generation failed due to validation errors.")
            return 1
        
        # Output result
        if args.output:
            with open(args.output, 'w') as f:
                f.write(wrapper_code)
            print(f"Wrapper generated: {args.output}")
        else:
            print(wrapper_code)
            
    except FileNotFoundError as e:
        print(f"Error: {e}")
        return 1
    except Exception as e:
        print(f"Error: {e}")
        return 1
    
    return 0


if __name__ == "__main__":
    exit(main())